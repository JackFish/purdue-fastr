package r.nodes.truffle;

import com.oracle.truffle.api.frame.*;
import com.oracle.truffle.api.nodes.*;

import r.*;
import r.analysis.codegen.DeepCopyable;
import r.data.*;
import r.nodes.*;

public abstract class RNode extends Node implements DeepCopyable {

    public ASTNode getAST() {
        return ((RNode) getParent()).getAST();
    }

    public abstract Object execute(Frame frame);

    public int executeScalarLogical(Frame frame) throws UnexpectedResultException {
        return RValueConversion.expectScalarLogical((RAny) execute(frame));
    }

    public int executeScalarInteger(Frame frame) throws UnexpectedResultException {
        return RValueConversion.expectScalarInteger((RAny) execute(frame));
    }

    public int executeScalarNonNALogical(Frame frame) throws UnexpectedResultException {
        return RValueConversion.expectScalarNonNALogical((RAny) execute(frame));
    }

    public Object executeVoid(Frame frame) {
        execute(frame);
        return RNull.getNull();
    }

    /** Default constructor.
     *
     * Defined only so that the copy or move constructor does not hide it.
     */
    protected RNode() {
    }

    /** Copy or move constructor.
     *
     * Should return a shallow (move) or deep (copy) copy of the object. Unless this constructor is overriden it the subclasses, its tailored version will be created by the FastrLoader when the class is loaded.
     *
     * @param other Object to be copied.
     * @param deep Should it be shallow or deep copy.
     */
    protected RNode(RNode other, boolean deep) {
    }

    /** Deep copy method.
     *
     * The overriden deep copy method autogenerated by the FastrLoader class loader if not provided explicitly in the code should be provided. This method is just a placeholder to make the IDEs and analysis think that everything is OK with the Java code.
     *
     * @return Deep copy of the object.
     */
    @Override
    public RNode deepCopy() {
        assert false : "This function should never be called! You must use FastrLoader.";
        return null;
    }

    public static class PushbackNode extends BaseR {
        @Child RNode realChildNode;
        final Object nextValue;

        public PushbackNode(ASTNode ast, RNode realChildNode, Object nextValue) {
            super(ast);
            realChildNode.replace(this);
            this.realChildNode = adoptChild(realChildNode);
            this.nextValue = nextValue;
        }

        @Override
        public Object execute(Frame frame) {
            try {
                throw new UnexpectedResultException(null);
            } catch (UnexpectedResultException e) {
                replace(realChildNode);
                return nextValue;
            }
        }
    }

    public <T extends RNode> void pushBack(T childNode, Object value) {
        new PushbackNode(childNode.getAST(), childNode, value);
    }

    public <T extends RNode> Object replace(T childNode, Object childValue, RNode newNode, Frame frame) {
        pushBack(childNode, childValue);
        return replace(newNode).execute(frame);
    }

}
