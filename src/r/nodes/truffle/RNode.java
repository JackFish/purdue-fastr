package r.nodes.truffle;

import com.oracle.truffle.api.frame.*;
import com.oracle.truffle.api.nodes.*;

import r.*;
import r.analysis.codegen.DeepCopyable;
import r.analysis.visitors.NodeVisitor;
import r.data.*;
import r.nodes.*;

public abstract class RNode extends Node implements DeepCopyable {

    public ASTNode getAST() {
        if (getParent() == null)
            System.out.println("AAAA");
        return ((RNode) getParent()).getAST();
    }

    public abstract Object execute(Frame frame);

    public int executeScalarLogical(Frame frame) throws UnexpectedResultException {
        return RValueConversion.expectScalarLogical((RAny) execute(frame));
    }

    public int executeScalarInteger(Frame frame) throws UnexpectedResultException {
        return RValueConversion.expectScalarInteger((RAny) execute(frame));
    }

    public int executeScalarNonNALogical(Frame frame) throws UnexpectedResultException {
        return RValueConversion.expectScalarNonNALogical((RAny) execute(frame));
    }

    public Object executeVoid(Frame frame) {
        execute(frame);
        return RNull.getNull();
    }

    /** Default constructor.
     *
     * Defined only so that the deep or shallow constructor does not hide it.
     */
    protected RNode() {
    }

    /** Deep or shallow constructor
     *
     * Should return a shallow (move) or deep (copy) copy of the object. Unless this constructor is overriden it the
     * subclasses, its tailored version will be created by the FastrLoader when the class is loaded.
     *
     * The complex form of deep or shallow constructor is used to avoid clashes with potentially existing standard copy
     * constructors that might have different semantics. An error is reported by the loader if only one of deep or
     * shallow constructor, or the deepCopy method is missing.
     *
     * @param other Object to be copied.
     * @param deep Should copy constructor create shallow or deep copy.
     */
    protected RNode(RNode other, boolean deep) {
    }

    /** Deep copy method.
     *
     * The overriden deep copy method autogenerated by the FastrLoader class loader if not provided explicitly in the
     * code should be provided. This method is just a placeholder to make the IDEs and analysis think that everything is
     * OK with the Java code.
     *
     * @return Deep copy of the object.
     */
    @Override
    public DeepCopyable deepCopy() {
        assert false : "This function should never be called! You must use FastrLoader.";
        return null;
    }

    /** Node visiting mechanism.
     *
     * The overriden accept method is generated by the FastrLoader to walk first the node itself and then all its fields
     * that inherit from RNode unless the visit of the node itself returned false.
     *
     * For more details see the NodeVisitor interface and the FastrLoader class.
     */
    public boolean accept(NodeVisitor visitor) {
        return visitor.visit(this);
    }

    /** Behavior check method.
     *
     * Each node should override this method to perform checks on the behavior annotations. Unless the method is
     * overwritten in the subclasses, it is automatically generated if an annotation with complex checking (defined
     * check method argument) is present.
     *
     * For simple behavior annotations, the check gets down to the node class being annotated with the given behavior.
     *
     * The behaviorCheck method is either generated automatically by the FastrLoader if annotations for conditional
     * behaviors are present for a subclass, or can always be overriden by the user directly. In this case, it is
     * important to call the parent implementation at the end of the overriden method instead of returning false.
     *
     * @param behavior Behavioral annotation to check for.
     * @return True if the behavior is supported by the node, false otherwise.
     *
     * TODO if fine grained behaviors are ever present they can be checked by creating a behaviorCheck method with
     * additional Object value that will be casted, or by embedding this only to the guards themselves and when a
     * behavior is detected, it will be checked by the guard for its validation on the fine level.
     */
    public boolean behaviorCheck(Class behavior) {
        return this.getClass().getAnnotation(behavior) != null;
    }


    public static class PushbackNode extends BaseR {
        @Child RNode realChildNode;
        final Object nextValue;

        public PushbackNode(ASTNode ast, RNode realChildNode, Object nextValue) {
            super(ast);
            realChildNode.replace(this);
            this.realChildNode = adoptChild(realChildNode);
            this.nextValue = nextValue;
        }

        @Override
        public Object execute(Frame frame) {
            try {
                throw new UnexpectedResultException(null);
            } catch (UnexpectedResultException e) {
                replace(realChildNode);
                return nextValue;
            }
        }
    }

    public <T extends RNode> void pushBack(T childNode, Object value) {
        new PushbackNode(childNode.getAST(), childNode, value);
    }

    public <T extends RNode> Object replace(T childNode, Object childValue, RNode newNode, Frame frame) {
        pushBack(childNode, childValue);
        return replace(newNode).execute(frame);
    }

}
